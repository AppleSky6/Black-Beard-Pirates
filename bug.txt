2018-10-29
(1)UEF异常调试器无法捕获，调试起来很麻烦！

2018-11-05
(2)被注入的程序hook了某些函数（我的异常处理必须调用的函数），然后他的执行是在一块被我设置了不可执行的内存块上，这样到导致我的异常处理无限递归。
想法：全局变量，产生异常的时候第一时间将这块内存的基地址加入链表标记已处理。（产生的bug更多了）

2018-11-06
（1）发现有样本是通过获取默认堆，然后改变页属性来跑代码，绕过了申请内存（sha1：740fad9d2be6c7082f0042b2112c6ad3a6afe9bc），然后下一步hook VirtualProtect来获取内存执行的代码。
（2）以前是通过异常来获取eip然后调用VirtualQuery从eip 所指的位置以0x1000向前递减，找到块首，然后dup，改进为从申请内存处获取大小然后存储成链表，异常后直接去判断位置dump，提高效率。

2018-11-07
（1）解决默认堆执行代码没有dup的bug。下一步继续优化代码，（多线程的问题）
